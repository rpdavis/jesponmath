# AI Question Generation Integration Analysis

## Current State
- **Template-based system**: Hardcoded question templates based on pattern matching
- **Limitations**: 
  - Only handles predefined patterns (multi-step scenarios, word problems, etc.)
  - Can't adapt to unique or complex goal descriptions
  - Requires manual updates for new question types
  - Example: Carter's goal required manual fix to detect "multi-step real-world scenario"

## AI Integration: Difficulty Assessment

### **Difficulty: MODERATE** ⚠️

**Why it's not too hard:**
- ✅ Modern AI APIs (OpenAI, Anthropic, Google) are well-documented
- ✅ Simple HTTP requests with JSON responses
- ✅ Can be integrated as a service layer
- ✅ Good TypeScript support

**Why it's not trivial:**
- ⚠️ Requires API key management and security
- ⚠️ Cost considerations (per API call)
- ⚠️ Latency (1-3 seconds per question)
- ⚠️ Error handling and fallbacks needed
- ⚠️ Prompt engineering for consistent results
- ⚠️ Rate limiting and quota management

## Implementation Approach

### Option 1: **Hybrid Approach** (Recommended)
- Use AI for complex/unique goals
- Fall back to templates for common patterns
- Best of both worlds: flexibility + reliability

### Option 2: **Full AI**
- All questions generated by AI
- More flexible but slower and more expensive

### Option 3: **AI-Assisted Templates**
- AI generates question text, templates provide structure
- Good balance of quality and control

## Recommended: Hybrid Approach

### Benefits:
1. **Flexibility**: Handles unique goal descriptions
2. **Quality**: Context-aware questions that match goals better
3. **Reliability**: Templates as fallback if AI fails
4. **Cost Control**: Only use AI when needed
5. **Performance**: Fast templates for common cases

### Implementation Steps:

1. **Create AI Service** (`src/services/aiQuestionGenerator.ts`)
   - Wrapper for OpenAI/Anthropic API
   - Prompt engineering for question generation
   - Error handling and retries

2. **Update Question Generator**
   - Check if goal matches common patterns → use template
   - Otherwise → call AI service
   - Fallback to template if AI fails

3. **Configuration**
   - Environment variables for API keys
   - Feature flag to enable/disable AI
   - Cost tracking and limits

4. **Caching**
   - Cache AI-generated questions for similar goals
   - Reduce API calls and costs

## Cost Estimates

### ⚠️ Important: ChatGPT Plus vs OpenAI API

**ChatGPT Plus ($20/month subscription):**
- ❌ Does NOT include API access
- ✅ Only for using ChatGPT web interface/app
- ❌ Cannot be used for programmatic API calls

**OpenAI API (separate billing):**
- ✅ Pay-as-you-go, separate from Plus subscription
- ✅ Requires separate API key and payment method
- ✅ Very affordable: GPT-3.5 Turbo ~$0.002 per question
- ✅ No monthly subscription needed (just pay for what you use)

### OpenAI GPT-4:
- ~$0.03 per question (input + output)
- 100 goals × 5 questions = 500 questions = ~$15
- Monthly: ~$50-200 depending on usage

### OpenAI GPT-3.5 Turbo (recommended - cheapest):
- ~$0.002 per question
- 100 goals × 5 questions = 500 questions = ~$1
- Monthly: ~$5-20 depending on usage
- **Best value for question generation**

### Google Gemini (free tier available):
- Free tier: 15 requests/minute
- Paid: Similar pricing to GPT-3.5
- Good alternative if you want to avoid API costs

## Code Structure Example

```typescript
// src/services/aiQuestionGenerator.ts
export async function generateQuestionWithAI(
  goal: Goal,
  subject: 'math' | 'ela' | 'other',
  questionNumber: number
): Promise<QuestionResult> {
  // Call AI API with well-crafted prompt
  // Return structured question + answer
}

// src/components/management/ProgressAssessmentManagement.vue
const generateQuestionWithAnswer = async (goal, subject, assessmentNumber, questionNumber) => {
  // 1. Check if goal matches common pattern
  if (matchesCommonPattern(goal)) {
    return generateWithTemplate(goal, subject, questionNumber)
  }
  
  // 2. Try AI generation
  try {
    return await generateQuestionWithAI(goal, subject, questionNumber)
  } catch (error) {
    console.warn('AI generation failed, using template fallback:', error)
    return generateWithTemplate(goal, subject, questionNumber)
  }
}
```

## Security Considerations

1. **API Keys**: Store in environment variables, never commit
2. **Rate Limiting**: Prevent abuse
3. **Input Sanitization**: Clean goal text before sending to AI
4. **Output Validation**: Verify AI returns valid question format
5. **Cost Limits**: Set monthly/daily spending caps

## Recommendation

**Start with Hybrid Approach:**
1. Keep existing templates for common patterns (fast, free, reliable)
2. Add AI for edge cases and unique goals
3. Monitor costs and quality
4. Gradually expand AI usage if beneficial

**Implementation Time:**
- Basic AI service: 2-3 hours
- Integration: 1-2 hours
- Testing & refinement: 2-3 hours
- **Total: ~6-8 hours**

## Next Steps

If you want to proceed:
1. Choose AI provider (OpenAI, Anthropic, or Google)
2. Set up API key in environment variables
3. Create AI service wrapper
4. Integrate with existing question generator
5. Add feature flag for gradual rollout
6. Test with debugger component we just created

